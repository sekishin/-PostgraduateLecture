プログラムの実行後に確保した共有メモリセグメント，セマフォ配列，メッセージキューが残っていないか確認し，残っている場合は削除すること．
確認方法：コマンドプロンプトが出ている状態で ipcs と入力し， 表示されたものの中に所有者が自分のユーザIDになっているものがないか調べる．
削除方法：残っているものが，共有メモリセグメント，セマフォ配列，メッセージキューに応じて以下のコマンドを入力する．
タイプ	コマンド
共有メモリセグメント	ipcrm -m 対象の共有メモリセグメントのshmid
セマフォ配列	ipcrm -s 対象のセマフォ配列のsemid
メッセージキュー	ipcrm -q 対象のメッセージキューのmsqid
gin.eng.kagawa-u.ac.jp:~79784547/CP/Proc/ProdCons.c (lecweb.eng.kagawa-u.ac.jpでは，~sai/CP/Proc/ProdCons.c) を参考にして，以下のプロデューサ―コンシューマ問題のプログラムを作成せよ．

レポートには，作成したプログラム，グラフ化した実行結果および考察あるいは修得できたこと を記述すること．

この課題は練習課題であり，最終回のプレゼンテーションの対象にはならない．対象となる課題については後日提示する．
引数として，以下の N，l，L，m，M の5つを持つ．
N：リングバッファの大きさ
l：1つのプロデューサプロセスが生産するデータの個数
L：プロデューサプロセス数
m：1つのコンシューマプロセスが消費するデータの個数
M：コンシューマプロセス数
l x L = m x M を満足する．

メインプロセスの動作
l x L = m x M でなければエラーメッセージを出力し，直ちに終了
共有メモリ上に，N 個の数字を保持できるリングバッファおよびその制御変数を確保する．
リングバッファをどのように制御するかは各自の判断に任せる．
L 個のプロデューサプロセスとM 個のコンシューマプロセスを適当なIDを与えて生成する．
生成した全てのプロセスが終了するまで待つ．
このとき，どのプロセスが終了したのかを示すために，実行時に与えたのIDと終了時刻を表示する．
フォークした子プロセスのプロセスIDと実行時に与えたIDの組からなる配列を用意し，Waitの返値と一致するプロセスIDを配列で検索することで，実行時に与えたIDを調べることができる．

プロデューサプロセスの処理：
以下の処理を l 回繰り返し，終了する．
20〜80の範囲の数字をランダムに発生する．
発生した数字をリングバッファに入れる．
現在バッファに入っている数字の個数を表示する．
20ミリ秒〜80ミリ秒の範囲でランダムにスリープする．

コンシューマプロセスの処理：
以下の処理を m 回繰り返し，終了する．
バッファから数字を取り出す．
現在バッファに入っている数字の個数を表示する．
取り出した数字分のミリ秒をスリープする．


N >= 15，l x L >= 3N の条件下で，以下の場合で実行してみる．
L = M
L > M
L < M
